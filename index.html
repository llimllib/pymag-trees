<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<style>
body {
    width: 800px;
    margin: auto;
}
#rightim { float:right;
           text-align:right;
           margin: 10px;}
#leftim { float:left;
           text-align:left;
           margin: 10px;}
</style>
</head>
<body>

 <div class="mainDiv">

<h1>Drawing Presentable Trees</h1>
<p><b><i>by Bill Mill</i></b></p>
<p>When I needed to draw some trees for a project I was doing, I assumed that there would be a classic, easy algorithm for drawing neat trees. What I found instead was much more interesting: not only is tree layout an NP-complete problem<sup><a href="#foot1">1</a></sup>, but there is a long and interesting history behind tree-drawing algorithms. I will use the history of tree drawing algorithms to introduce central concepts one at a time, using each of them to build up to a complete O(n) algorithm for drawing attractive diagrams of trees.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading1"><h2 class="articleHeading">What&#039;s the problem here?</h2>
<div id="rightim"> 
    <img src="images/figure1.png">
    <br><em>figure 1</em>
</div>
</a>Given a tree T, what we&#039;re going to try and do is draw it in such a way that the viewer will find it attractive. The goal of each algorithm presented in this article will be to assign each node of the tree an (x,y) coordinate so that it can be drawn to the screen or printed after the algorithm has run.</p>
<p class="ceresIndent">In order to store the results of the tree drawing algorithms, we&#039;ll create a DrawTree data structure to mirror the tree we&#039;re drawing; the only thing we&#039;ll assume is that each tree node can iterate over its children. A basic implementation of DrawTree can be found in Listing 1.</p>
<pre>
class DrawTree(object):
    def __init__(self, tree, depth=0):
        self.x = -1
        self.y = depth
        self.tree = tree
        self.children = [DrawTree(t, depth+1) for t in tree]
</pre>
<p class="ceresIndent">As the sophistication of our methods increase, so will the complexity of DrawTree. For now, it just assigns -1 to the x coordinate of each node, the depth of the node to its y coordinate, and stores a reference to the root of the current tree. Then it builds up a list of the children of that node by recursively creating a DrawTree for each one. In this way, we build a DrawTree that wraps the tree it&#039;s going to draw and adds drawing-specific information to each node.</p>
<p class="ceresIndent">As we go along implementing better algorithms throughout this article, we&#039;ll use our experience with each to help us generate principles that will aid us in constructing the next one. Although generating an "attractive" tree diagram is matter of taste, these principles will help to guide us in improving the output of our programs.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading2"><h2 class="articleHeading">In the beginning, there was Knuth</h2></a>The particular type of drawing that we&#039;ll be making is one where the root is at the top, its children are below it, and so on. This type of diagram, and thus this entire class of problems, owes largely to Donald Knuth<sup><a href="#foot2">2</a></sup>, from whom we will draw our first two principles:</p>
<p class="ceresIndent"><strong>Principle 1</strong>: <i> The edges of the tree should not cross each other.</i></p>
<p class="ceresIndent"><strong>Principle 2</strong>: <i> All nodes at the same depth should be drawn on the same horizontal line. This helps make clear the structure of the tree.</i></p>
<div id="rightim"> 
    <img src="images/figure2.png">
    <br><em>figure 2</em>
</div>
<p class="ceresIndent">The Knuth algorithm has the advantage of simplicity and blazing speed, but it only works on binary trees and it can produce some fairly misshapen drawings. It is a simple <i>inorder</i> traversal of a tree, with a global counter that is used as the x variable, then incremented at each node. The code in Listing 2 demonstrates this technique.</p>
<pre>
i = 0
def knuth_layout(tree, depth):
    if tree.left_child: 
        knuth_layout(tree.left_child, depth+1)
    tree.x = i
    tree.y = depth
    i += 1
    if tree.right_child: 
        knuth_layout(tree.right_child, depth+1)
</pre>
<p class="ceresIndent">As you can see from Figure 2, this algorithm produces a tree that satisfies Principle 1, but is not particularly attractive. You can also see that Knuth diagrams will grow wide very quickly, since they will not reuse x coordinates even when the tree could be significantly narrower. To avoid this waste of space, we&#039;ll introduce a third principle:</p>
<p class="ceresIndent"><strong>Principle 3</strong>: <i> Trees should be drawn as narrowly as possible.</i></p>
<p class="ceresIndent"><a style="headerAnchor" name="heading3"><h2 class="articleHeading">A Brief Refresher</h2></a>Before we go on towards some more advanced algorithms, It&#039;s probably a good idea to stop and agree on the terms we&#039;ll use in this article. First, we&#039;re going to make use of a metaphor to family trees when describing the relationships between our data nodes. A node can have <i>children</i> below it, <i>siblings</i> to its left or right, and a <i>parent</i> above it.</p>
<p class="ceresIndent">We already talked about inorder tree traversals, and we&#039;re also going to talk about <i>preorder</i> and <i>postorder</i> traversals.. You probably saw these three terms on a "Data Structures" test a long time ago, but unless you&#039;ve been playing with trees lately, they may have gotten a bit hazy.</p>
<p class="ceresIndent">The traversal types simply determine when we do the processing we need to do on a given node. <i>Inorder</i> traversal, as in the Knuth algorithm above, only applies to binary trees, and means that we process the left child, then process the current node, then finally the right child. <i>Preorder</i> traversal means we process the current node, then all its children, and <i>posterder</i> traversal is simply the reverse.</p>
<p class="ceresIndent">Finally, you may have seen the concept of <i>Big O notation</i> before as a way to express the order of magnitude of the run time for an algorithm. In this article, we&#039;re going to play fast and loose with it, using it as a simple tool to distinguish acceptable runtimes from unacceptable ones. If an algorithm already in its main loop frequently loops through all the children of one of its nodes, we&#039;re going to call it <code>O(n^2)</code>, or <i>quadratic</i>. Anything else we&#039;re going to call O(n), or <i>linear</i>. If you want more details, the papers referenced at the end of this article contain a great deal more about the runtime characteristics of these algorithms.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading4"><h2 class="articleHeading">From the Bottom Up</h2>
<div id="rightim"> 
    <img src="images/figure3.png">
    <br><em>figure 3</em>
</div>
</a>Charles Wetherell and Alfred Shannon<sup><a href="#foot3">3</a></sup> came along in 1979, 8 years after Knuth introduced the tree layout problem, and introduced a whole raft of innovative techniques. First, they showed how to generate the minimum width tree that satisfies our first three principles. Simply maintain the next available slot on each row, traverse the tree in postorder, assign a node that slot, and increment the slot counter, as in Listing 3.</p>
<pre>
nexts = [0] * maximum_depth_of_tree

def minimum_ws(tree, depth=0):
    tree.x = nexts[depth]
    tree.y = depth
    nexts[depth] += 1
    for c in tree.children:
        minimum_ws(tree, c)
</pre>
<p class="ceresIndent">Although it satisfies all of our principles, perhaps you will agree that the output is ugly. Even on a simple example such as that in Figure 3, it&#039;s difficult to quickly ascertain the relationships between the nodes, and the whole thing seems smooshed together. It&#039;s about time we introduce another principle that would help clean up both the Knuth tree and the minimum width tree:</p>
<p class="ceresIndent"><strong>Principle 4</strong>: <i> A parent should be centered over its children.</i></p>
<div id="leftim"> 
    <img src="images/figure4.png">
    <br><em>figure 4</em>
</div>
<p class="ceresIndent">Up to now, we&#039;ve been able to get away with very simple algorithms to draw trees because we&#039;ve not really had to consider local context; we&#039;ve relied on global counters to keep our nodes from overlapping each other. In order to satisfy the principle that a parent should be centered over its children, we&#039;ll need to consider each node&#039;s local context, and so a few new strategies are necessary.</p>
<p class="ceresIndent">The first strategy that Wetherell and Shannon introduce is to build trees up from the bottom with a post-order traversal of the tree, instead of going from the top down like Listing 2, or through the middle like Listing 3. Once you look at the tree this way, centering the parent is an easy operation - simply divide its children&#039;s x coordinates in half.</p>
<p class="ceresIndent">We must remember, though, to stay mindful of the left side of the tree when constructing the right. Figure 4 shows a scenario where the right side of the tree has been pushed out to the right in order to accommodate the left. To accomplish this separation, Wetherell and Shannon maintain the array of next available spots introduced with Listing 2, but only use the next available spot if centering the parent would cause the right side of the tree to overlap the left side.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading5"><h2 class="articleHeading">The Mods and the Rockers</h2></a>Before we start looking at more code, let&#039;s take a closer look at the consequences of our bottom up construction of the tree. We&#039;ll give each node the next available x coordinate if it&#039;s a leaf, and center it above its children if it&#039;s a branch. However, if centering the branch will cause it to come into conflict with another part of the tree, we need to move it to the right far enough to avoid the conflict.</p>
<p class="ceresIndent">When we move a branch to the right, we have to move all of its children, or else we will have lost the centered parent node that we&#039;ve been working so hard to maintain. It&#039;s easy to come up with a naive function to move a branch and its subtrees to the right by some number:</p>
<pre>
def move_right(branch, n):
    branch.x += n
    for c in branch.children:
        move_right(c, n)
</pre>
<p class="ceresIndent">It works, but presents a problem. If we use this function to move a subtree to the right, we&#039;ll be doing recursion (to move the tree) inside of recursion (to place the nodes), which means we&#039;ll have an inefficient algorithm which may run in time O(n^2).</p>
<p class="ceresIndent">To solve this problem, we&#039;ll give each node an additional member called <code>mod</code>. When we come to a branch that we need to move to the right by <code>n</code> spaces, we&#039;ll add <code>n</code> to its <code>x</code> coordinate and to its <code>mod</code> value, and happily continue along with the placement algorithm. Because we&#039;re moving from the bottom up, we don&#039;t need to worry about the bottom of our trees coming into conflict (we&#039;ve already shown they&#039;re not), and we&#039;ll wait until later to move them to the right.</p>
<p class="ceresIndent">Once the first tree traversal has taken place, we run a second tree traversal to move the branches to the right that need to be moved to the right. Since we&#039;ll visit each node once and perform only arithmetic on it, we can be sure that this traversal will be O(n) just like the first one is, and together that they will be O(n) as well.</p>
<p class="ceresIndent">The code in Listing 5 demonstrates both the centering of parent nodes and the use of mod values to improve the efficiency of our code.</p>
<pre>
from collections import defaultdict

class DrawTree(object):
    def __init__(self, tree, depth=0):
        self.x = -1
        self.y = depth
        self.tree = tree
        self.children = [DrawTree(t, depth+1) for t in tree]
        self.mod = 0

def layout(tree):
    setup(tree)
    addmods(tree)
    return tree

def setup(tree, depth=0, nexts=None, offset=None):
    if nexts is None:  nexts  = defaultdict(lambda: 0)
    if offset is None: offset = defaultdict(lambda: 0)

    for c in tree.children:
        setup(c, depth+1, nexts, offset)

    tree.y = depth
    
    if not len(tree.children):
        place = nexts[depth]
        tree.x = place
    elif len(tree.children) == 1:
        place = tree.children[0].x - 1
    else:
        s = (tree.children[0].x + tree.children[1].x)
        place = s / 2

    offset[depth] = max(offset[depth], nexts[depth]-place)

    if len(tree.children):
        tree.x = place + offset[depth]

    nexts[depth] += 2
    tree.mod = offset[depth]

def addmods(tree, modsum=0):
    tree.x = tree.x + modsum
    modsum += tree.offset

    for t in tree.children:
        addmods(t, modsum)
</pre>
<p class="ceresIndent"><a style="headerAnchor" name="heading6"><h2 class="articleHeading">Trees as Blocks</h2></a>While it does produce good results in many cases, Listing 5 can produce some disfigured trees, such as the one in Figure 5 (<em>ed: sadly, lost to the sands of time</em>). A further difficulty in interpreting the trees produced by the Wetherell-Shannon algorithm is that the same tree structure, when placed at a different point in the tree, may be drawn differently. To avoid this, we&#039;ll steal a principle from a paper by Edward Reingold and John Tilford<sup><a href="#foot4">4</a></sup>:</p>
<p class="ceresIndent"><strong>Principle 5</strong>: <i> A subtree should be drawn the same no matter where in the tree it lies.</i></p>
<p class="ceresIndent">Even though this may widen our drawings a bit, this principle will help to make them convey more information. It will also help to simplify our bottom-up traversal of the tree, since one of its consequences is that once we&#039;ve figured out the x coordinates of a subtree, we only need to move it left or right as a unit.</p>
<p class="ceresIndent">Here is a sketch of the algorithm implemented in Listing 6:</p>
<pre>
&bull; Do a post-order traversal of the tree
&bull; if the node is a leaf, give it an x coordinate of 0
&bull; else, place its right subtree as close to the left as possible without conflict
    &bull; Use the same mod technique as in the previous algorithm to move the tree in O(n) time
&bull; place the node halfway between its children
&bull; Do a second walk of the tree, adding the
  accumulated mod value to the x coordinate
</pre>
<p class="ceresIndent">This algorithm is simple to the point of brilliance, but to execute it we&#039;ll need to introduce a bit of complexity.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading7"><h2 class="articleHeading">Contours</h2>
<div id="rightim"> 
    <img src="images/figure6.png">
    <br><em>figure 6</em>
</div>
</a>The <i>contour</i> of a tree is a list of the maximum or minimum coordinates of the a side of the tree. In Figure 6, there is a left tree and a right tree, with the x-coordinate of each node overlaid. If we trace down the left side of the left tree, taking the minimum x coordinate of each level, we get [1,1,0], which we call the <i>left contour</i> of the tree. If we trace down the right side, taking the rightmost x-coordinate from each level, we get [1,1,2], which is the <i>right contour</i> of the tree.</p>
<p class="ceresIndent">To find the left contour of the right tree, we again take the x-coordinate of the leftmost node on each level, giving us [1,0,1]. This time, the contour has an interesting property that not all nodes are connected in a parent-child relationship; the 0 on the second level is not the parent of the 1 on the third.</p>
<p class="ceresIndent">If we were to join these two trees according to Listing 6, we could find the right contour of the left tree, and the left contour of the right tree. Then we could easily find the smallest amount that we needed to push the right tree to the right so that it didn&#039;t overlap the left tree. A simple method for doing so is given in Listing 7.</p>
<pre>
from operator import lt, gt

def push_right(left, right):
    wl = contour(left, lt)
    wr = contour(right, gt)
    return max(x-y for x,y in zip(wl, wr)) + 1
    
def contour(tree, comp, level=0, cont=None):
    if not cont: 
        cont = [tree.x]
    elif len(cont) < level+1:
        cont.append(tree.x)
    elif comp(cont[level], tree.x):
        cont[level] = tree.x

    for child in tree.children:
        contour(child, comp, level+1, cont)

    return cont
</pre>
<p class="ceresIndent">If we run the procedure <code>push_right()</code> from Listing 7 on the tree from Figure 6, we will get [1,1,2] as the right contour of the left tree and [1,0,1] as the left contour of the right tree. We then compare these lists to find the maximum space between them, and add one space for padding. In the case of Figure 6, pushing the right tree to the right by 2 spaces will prevent it from overlapping the left tree.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading8"><h2 class="articleHeading">New Threads</h2></a>Using the code in Listing 7, we found the correct value for how far we had to push the right tree, but to do so we had to scan every node in both subtrees to get the contours we needed. Since it is very likely an O(n^2) operation, Reingold and Tilford introduce a concept confusingly called <i>threads</i>, which are not at all like the threads used for parallel execution.</p>
<div id="rightim"> 
    <img src="images/figure7.png">
    <br><em>figure 7</em>
</div>
<p class="ceresIndent">Threads are a method for reducing the amount of time it takes to scan a subtree for its contour by creating links between nodes on the contour if one is not already the child of the other. In Figure 7, the dotted line represents a thread while a solid line represents a parent-child relationship.</p>
<p class="ceresIndent">We can also take advantage of the fact that, if the one tree is deeper than the other, we only need to descend as far as the shorter tree. Anything deeper than that will not affect the separation necessary between the two trees, since there can be no conflicts between them.</p>
<p class="ceresIndent">Using threads and only traversing as deeply as we need to, we can get a contour for a tree and set our threads in linear time with the procedure in Listing 8.</p>
<pre>
def nextright(tree):
    if tree.thread:   return tree.thread
    if tree.children: return tree.children[-1]
    else:             return None

def nextleft(tree):
    if tree.thread:   return tree.thread
    if tree.children: return tree.children[0]
    else:             return None

def contour(left, right, max_offset=0, left_outer=None, right_outer=None):
    if not left_outer:
        left_outer = left
    if not right_outer:
        right_outer = right

    if left.x - right.x > max_offset:
        max_offset = left.x - right.x

    lo = nextleft(left)
    li = nextright(left)
    ri = nextleft(right)
    ro = nextright(right)

    if li and ri:
        return contour(li, ri, max_offset, lo, ro)

    return max_offset
</pre>
<p class="ceresIndent">It&#039;s easy to see that this procedure only visits two nodes on each level of the subtree being scanned. The paper has a neat proof that this occurs in linear time; I recommend that you go read it if you&#039;re interested.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading9"><h2 class="articleHeading">Putting it all Together</h2></a>The contour procedure given in Listing 8 is neat and fast, but it won&#039;t work with the mod technique we discussed earlier, because the actual x value of a node is the node&#039;s x value <i>plus</i> the sum of all the modifiers on the path from itself to the root. To handle this case, we&#039;ll need to add another couple bits of complexity to our contour algorithm.</p>
<p class="ceresIndent">The first thing we need to do is maintain two additional variables, a sum of the modifiers on the left subtree and a sum of the modifiers on the right subtree. These sums are necessary to compute the actual position of each node on the contour, so that we can check to see if it conflicts with a node on the opposite side. See Listing 9.</p>
<pre>
def contour(left, right, max_offset=None, loffset=0, roffset=0, left_outer=None, right_outer=None):
    delta = left.x + loffset - (right.x + roffset)
    if not max_offset or delta > max_offset:
        max_offset = delta

    if not left_outer:
        left_outer = left
    if not right_outer:
        right_outer = right

    lo = nextleft(left_outer)
    li = nextright(left)
    ri = nextleft(right)
    ro = nextright(right_outer)

    if li and ri:
        loffset += left.offset
        roffset += right.offset
        return contour(li, ri, max_offset,
                       loffset, roffset, lo, ro)

    return (li, ri, max_offset, loffset, roffset, left_outer, right_outer)
</pre>
<p class="ceresIndent">The other thing we need to do is return the current state of the function when we exit so that we can set the proper offset on the threaded nodes. With that information in hand, we&#039;re ready to look at the function that uses the code in Listing 8 to place two trees as closely together as possible:</p>
<pre>
def fix_subtrees(left, right):
    li, ri, diff, loffset, roffset, lo, ro \
        = contour(left, right)
    diff += 1
    diff += (right.x + diff + left.x) % 2

    right.mod = diff
    right.x += diff

    if right.children:
        roffset += diff

    if ri and not li:
        lo.thread = ri
        lo.mod = roffset - loffset
    elif li and not ri:
        ro.thread = li
        ro.mod = loffset - roffset

    return (left.x + right.x) / 2
</pre>
<p class="ceresIndent">After we run the contour procedure, we add 1 to the maximum difference between the left and right trees so that they won&#039;t conflict with each other, then add another one if the midpoint between them is odd. This lets us keep a handy property for testing - all nodes have integral x coordinates, with no loss of precision.</p>
<p class="ceresIndent">Then we move the right tree the prescribed amount to the right. Remember here that the reason we both add diff to the x coordinate and save it to the mod value is that the mod value only applies to the nodes below the current node. If the right subtree has more than one node, we add diff to the roffset, since all children of the right node will be moved that far to the right.</p>
<p class="ceresIndent">If the left side of the tree was deeper than the right, or vice versa, we need to set a thread. We simply check to see if the node pointer for one side progressed farther than the node pointer for the other side, and if it has, set the thread from the outside of the shallower tree to the inside of the deeper one.</p>
<p class="ceresIndent">In order to properly handle the mod values that we talked about before, we need to set a special mod value on threaded nodes. Since we&#039;ve already updated our right offset value to reflect the right tree&#039;s movement to the right, all we need to do here is set the mod value of the threaded node to the difference between the offset of the deeper tree and itself.</p>
<p class="ceresIndent">Now that we have code in place to find the contours of trees and to place two trees as close together as possible, we can easily implement the algorithm described above. I present the rest of the code without comment:</p>
<pre>
def layout(tree):
    return addmods(setup(dt))

def addmods(tree, mod=0):
    tree.x += mod
    for c in tree.children:
        addmods(c, mod+tree.mod)
    return tree

def setup(tree, depth=0):
    if len(tree.children) == 0:
        tree.x = 0
        tree.y = depth
        return tree

    if len(tree.children) == 1:
        tree.x = setup(tree.children[0], depth+1).x
        return tree

    left = setup(tree.children[0], depth+1)
    right = setup(tree.children[1], depth+1)

    tree.x = fix_subtrees(left, right)
    return tree
</pre>
<p class="ceresIndent"><a style="headerAnchor" name="heading10"><h2 class="articleHeading">Extension to N-ary Trees</h2>
</a>Now that we&#039;ve finally got an algorithm for drawing binary trees which satisfies our principles, looks good in the general case, and runs in linear time, it&#039;s natural to think about how to extend it to trees with any amount of children. If you&#039;ve followed me this far, you&#039;re probably thinking that we should just take the wonderful algorithm we&#039;ve just defined and apply it across all the children of a node.</p>
<p class="ceresIndent">An extension of the previous algorithm to work on n-ary trees might look something like this:</p>
<p class="ceresIndent"><ul class="ceresUl"><li class="ceresLi">Do a post-order traversal of the tree</li><li class="ceresLi">if the node is a leaf, give it an x coordinate of 0</li><li class="ceresLi">otherwise, for each of its children, place the child as close to its left sibling as possible</li><li class="ceresLi">place the parent node halfway between its leftmost and rightmost children</li></ul>This algorithm works, and is fast, but suffers from a simple problem. It stuffs all of the subtrees of the node as far to the left as possible. If a node far on the right conflicts with one far on the left, the trees in between are all going to be stuffed to the right, as in Figure 7. Let&#039;s adopt one final principle for tree drawing to fix this problem:</p>
<p class="ceresIndent"><strong>Principle 6</strong>: <i> The child nodes of a parent node should be evenly spaced.</i></p>
<div id="rightim"> 
    <img src="images/figure8.png">
    <br><em>figure 8</em>
</div>
<p class="ceresIndent">In order to draw an n-ary tree symmetrically, and quickly, we&#039;re going to need all the tricks we&#039;ve developed so far plus a couple of new ones. Thanks to a recent paper by Christoph Buchheim et al<sup><a href="#foot5">5</a></sup>, we&#039;ve got all the tools at hand to do so and still be able to draw our trees in linear time.</p>
<p class="ceresIndent">To modify the algorithm above to meet Principle 6, we&#039;ll need a method for spacing out the trees in between two larger trees that conflict. The simplest method would be to, every time two trees conflict, divide the available space by the number of trees, and shift each tree so that it&#039;s separated by that amount from its siblings. For example, in Figure 7, there is some distance n between the large trees on the right and the left, and three trees in between them. If we simply spaced the first tree in the middle <code>n/3</code> away from the left tree, the next one <code>n/3</code> away from that, and so on, we&#039;d have a tree that satisfied Principle 6.</p>
<p class="ceresIndent">Every time so far that we&#039;ve looked at a simple algorithm in this article, we&#039;ve found it inadequate, and this time is no different. If we have to shift all the trees in between every two trees that conflict, we run the risk of introducing an O(n^2) operation into our algorithm.</p>
<p class="ceresIndent">The fix for this problem is similar to the fix for the previous shifting problem we had, for which we introduced <code>mod</code>. Instead of shifting each subtree in the middle every time we have a conflict, we&#039;ll save the value that we need to shift the trees in the middle, then apply the shifts after we&#039;ve placed all the children of a node.</p>
<p class="ceresIndent">In order to figure out the correct value we want to shift the middle nodes, we&#039;ll need to be able to find the number of trees in between the two nodes that conflict. When we only had two trees, it was obvious that any conflict that occurred was between the left and the right tree. When there may be any number of trees, finding out which tree is causing the conflict becomes a challenge.</p>
<p class="ceresIndent">To meet this challenge, we&#039;ll introduce a default_ancestor variable and add another member to our tree data structure, which we&#039;ll call the <code>ancestor</code>. The ancestor node either points to itself or to the root of the tree it belongs to. When we need to find which tree a node belongs to, we&#039;ll use the ancestor member if it is set, but fall back on the tree pointed to by <code>default_ancestor</code>.</p>
<p class="ceresIndent">When we place the first subtree of a node, we simply set default_ancestor to point to that subtree, and assume that any conflict caused by the next tree is with the first one. After we&#039;ve placed the second subtree, we distinguish two cases. If the second subtree is less deep than the first, we traverse its right contour, setting the ancestor member equal to the root of the second tree. Otherwise, the second tree is larger than the first, which means that any conflicts with the next tree to be placed with be with the second tree, and so we simply set default_ancestor to point to it.</p>
<p class="ceresIndent">So, without further ado, a python implementation of the O(n) algorithm for laying out attractive trees as presented by Buchheim is in Listing 12.</p>
<pre>
class DrawTree(object):
    def __init__(self, tree, parent=None, depth=0, number=1):
        self.x = -1.
        self.y = depth
        self.tree = tree
        self.children = [DrawTree(c, self, depth+1, i+1) 
                         for i, c
                         in enumerate(tree.children)]
        self.parent = parent
        self.thread = None
        self.offset = 0
        self.ancestor = self
        self.change = self.shift = 0
        self._lmost_sibling = None
        #this is the number of the node in its group of siblings 1..n
        self.number = number

    def left_brother(self):
        n = None
        if self.parent:
            for node in self.parent.children:
                if node == self: return n
                else:            n = node
        return n

    def get_lmost_sibling(self):
        if not self._lmost_sibling and self.parent and self != \
        self.parent.children[0]:
            self._lmost_sibling = self.parent.children[0]
        return self._lmost_sibling
    leftmost_sibling = property(get_lmost_sibling)

def buchheim(tree):
    dt = firstwalk(tree)
    second_walk(dt)
    return dt

def firstwalk(v, distance=1.):
    if len(v.children) == 0:
        if v.leftmost_sibling:
            v.x = v.left_brother().x + distance
        else:
            v.x = 0.
    else:
        default_ancestor = v.children[0]
        for w in v.children:
            firstwalk(w)
            default_ancestor = apportion(w, default_ancestor,
                                         distance)
        execute_shifts(v)

        midpoint = (v.children[0].x + v.children[-1].x) / 2

        ell = v.children[0]
        arr = v.children[-1]
        w = v.left_brother()
        if w:
            v.x = w.x + distance
            v.mod = v.x - midpoint
        else:
            v.x = midpoint
    return v

def apportion(v, default_ancestor, distance):
    w = v.left_brother()
    if w is not None:
        #in buchheim notation:
        #i == inner; o == outer; r == right; l == left;
        vir = vor = v
        vil = w
        vol = v.leftmost_sibling
        sir = sor = v.mod
        sil = vil.mod
        sol = vol.mod
        while vil.right() and vir.left():
            vil = vil.right()
            vir = vir.left()
            vol = vol.left()
            vor = vor.right()
            vor.ancestor = v
            shift = (vil.x + sil) - (vir.x + sir) + distance
            if shift > 0:
                a = ancestor(vil, v, default_ancestor)
                move_subtree(a, v, shift)
                sir = sir + shift
                sor = sor + shift
            sil += vil.mod
            sir += vir.mod
            sol += vol.mod
            sor += vor.mod
        if vil.right() and not vor.right():
            vor.thread = vil.right()
            vor.mod += sil - sor
        else:
            if vir.left() and not vol.left():
                vol.thread = vir.left()
                vol.mod += sir - sol
            default_ancestor = v
    return default_ancestor

def move_subtree(wl, wr, shift):
    subtrees = wr.number - wl.number
    wr.change -= shift / subtrees
    wr.shift += shift
    wl.change += shift / subtrees
    wr.x += shift
    wr.mod += shift

def execute_shifts(v):
    shift = change = 0
    for w in v.children[::-1]:
        w.x += shift
        w.mod += shift
        change += w.change
        shift += w.shift + change

def ancestor(vil, v, default_ancestor):
    if vil.ancestor in v.parent.children:
        return vil.ancestor
    else:
        return default_ancestor

def second_walk(v, m=0, depth=0):
    v.x += m
    v.y = depth

    for w in v.children:
        second_walk(w, m + v.mod, depth+1, min)
</pre>
<p class="ceresIndent"><a style="headerAnchor" name="heading11"><h2 class="articleHeading">Conclusion</h2></a>I&#039;ve glossed over a few things in this article, simply because I felt it was more important to try and present a logical progression to the final algorithm I presented than it was to overload the article with pure code. If you want more details, or to see the tree data structures that I&#039;ve used in the various code listings, you can go to <a class="ceresLink" href="http://github.com/llimllib/pymag-trees/">http://github.com/llimllib/pymag-trees/</a> to download the source code for each algorithm, some basic tests, and the code used to generate the figures for this article.</p>
<p class="ceresIndent"><a style="headerAnchor" name="heading12">
<h2 class="articleHeading">Footnotes</h2></a>
<sup><a name="foot1">1</a></sup> K. Marriott, NP-Completeness of Minimal Width Unordered Tree Layout, Journal of Graph Algorithms and Applications, vol. 8, no. 3, pp. 295-312 (2004). <a class="ceresLink" href="http://www.emis.de/journals/JGAA/accepted/2004/MarriottStuckey2004.8.3.pdf">http://www.emis.de/journals/JGAA/accepted/2004/MarriottStuckey2004.8.3.pdf</a></p>
<p class="ceresIndent"><sup><a name="foot2">2</a></sup> D. E. Knuth, Optimum binary search trees, Acta Informatica 1 (1971) </p>
<p class="ceresIndent"><sup><a name="foot3">3</a></sup> C. Wetherell, A. Shannon, Tidy Drawings of Trees, IEEE Transactions on Software Engineering. Volume 5, Issue 5 </p>
<p class="ceresIndent"><sup><a name="foot4">4</a></sup> E. M. Reingold, J. S Tilford, Tidier Drawings of Trees, IEEE Transactions on Software Engineering. Volume 7, Issue 2 </p>
<p class="ceresIndent"><sup><a name="foot5">5</a></sup> C. Buchheim, M. J Unger, and S. Leipert. Improving Walker&#039;s algorithm to run in linear time. In Proc. Graph Drawing (GD), 2002. <a class="ceresLink" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.8757">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.8757</a></p>
<p class="ceresIndent"></p> </div>
</body>
</html>

